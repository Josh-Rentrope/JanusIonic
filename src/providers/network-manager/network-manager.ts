import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Platform } from 'ionic-angular';

import { Geolocation } from '@ionic-native/geolocation';

import { Zeroconf } from '@ionic-native/zeroconf';
import { SettingsProvider } from '../../providers/settings/settings';
//import Bonjour from 'bonjour'
/*
  Generated class for the NetworkManagerProvider provider.

  See https://angular.io/guide/dependency-injection for more info on providers
  and Angular DI.
*/
@Injectable()
export class NetworkManagerProvider {
  peers :any;
  webserver: any;
  deviceData: any;
  constructor(public http: HttpClient, private zeroconf: Zeroconf, public plt: Platform, public settings: SettingsProvider) {
    // watch for services of a specified type
	let that = this;
	this.peers = {};
	this.plt.ready().then((readySource) => {
		this.zeroconf.watch('_http._tcp.', 'local.').subscribe(result => {
		  if (result.action == 'added') {
			//console.log('service added', result.service);
			that.peers[result.service.name] = (result.service);
			//console.log('service added', result.service);
			//console.log(that);
		  } else if(result.action == 'resolved') {
			if(result.service.ipv4Addresses){
			  that.peers[result.service.name].ipv4Addresses = result.service.ipv4Addresses;
		  	}
			 
			//console.log('service removed', result.service);
			//console.log(that);
		  }else {
			console.log(result.action);
			console.log('service removed', result.service);
		  }
		});

		console.log(this.zeroconf);
		// publish a zeroconf service of your own
		this.zeroconf.register('_http._tcp.', 'local.', 'Janus Android Node', 7995, {
		  'Group': ''
		}).then(result => {
		  console.log('Service registered', result.service);
		});
		//this.zeroconf.unregister('_http._tcp.', 'local.', 'Becvert\'s iPad');
		this.webserver = cordova.require('cordova-plugin-webserver.webserver');
		this.webserver.onRequest (
			function(request) {
				//console.log("Hello");
				
				var query = {};
				
				//console.log(request);
				if(request.query){
					var pairs = (request.query[0] === '?' ? request.query.substr(1) : request.query).split('&');
					for (var i = 0; i < pairs.length; i++) {
						var pair = pairs[i].split('=');
						query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
					}
				}
				that.getInformation(query).then((data) =>{
					that.webserver.sendResponse(
						request.requestId,
						{
							status: 200,
							body: data,
							headers: {

								'Access-Control-Allow-Origin': '*',
								'Content-Type': 'application/json'
							}
						}
					);
				});
				
			},
			()=>{},
			()=>{}
		);
		//console.log(this.webserver);
		this.webserver.start(
			()=>{console.log("Success")},
			(error)=>{console.log("Error"),error},
			7995
		);
	});
	//d console.log(this.webserver);
  }
  async getInformation(query){ //Will set this to be autogenerated
    let retDict :any = {
		Status:null
	};
	  if(query.action){ //Why did I think this was a good idea?
		  switch(query.action) {
			case "SetProperty":
				
				if(query.property == "Enabled" && this.deviceData){
					this.deviceData.ToggleDataCollection();
					retDict.Status = "Property Changed";
				}
				if(query.property == "CameraEnabled" && this.deviceData ){
					this.deviceData.ToggleDevice("Camera" );
					retDict.Status = this.deviceData.SensorData.Sensors.Camera.Enabled;
				}
				if(query.property == "MotionEnabled" && this.deviceData ){
					this.deviceData.ToggleDevice("Acceleration");
					retDict.Status = this.deviceData.SensorData.Sensors.Acceleration.Enabled;
				}
				if(query.property == "SoundEnabled" && this.deviceData ){
					this.deviceData.ToggleDevice("Sound");
					retDict.Status = this.deviceData.SensorData.Sensors.Sound.Enabled;
				}
				break;
			case "GetProperties":
				//code block
				break;
			case "GetData":
				//console.log("Getting Data");
				retDict.Data = this.deviceData.GetPriorData(query);
				break;
			case "GetIncident":
				//console.log("Getting Data");
				await this.deviceData.GetSpecificIncident(query.incident).then((data) => {retDict.Data = data});
				break;
			case "EraseData":
				//console.log("Getting Data");
				await this.deviceData.EraseData(query).then((data) => {retDict.Data = data});
				break;
			default:
				break
		  }
  	  }
	  console.log(retDict);
	  return retDict;
  }
  
  getDataFromAndroidNodes(postData = {}) {
    var headers = new HttpHeaders();
    headers.append('Access-Control-Allow-Origin' , '*');
    headers.append('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, PUT');
    headers.append("Accept", 'application/json');
    headers.append('Content-Type', 'application/json' );
    //const requestOptions = new HttpHeaders({ headers: headers });
	let that = this ;
	Object.keys(this.peers).forEach(function(key) {
		if(key.includes("Android") && that.peers[key].ipv4Addresses != []){
		  that.http.get("http://"+that.peers[key].ipv4Addresses[0]+":7995/?action=GetData", { headers: headers })
		  .subscribe(data => {
			  if(that.deviceData.SensorData.LastIncident){
			  	that.deviceData.SensorData.LastIncident.PeerData[that.peers[key].ipv4Addresses[0]] = data;
			  }
			  //console.log(data);
			//console.log(data['_body']);
		   }, error => {
			  console.log(error);
			//delete(that.peers[key]);
		  });
		}else if(key.includes("Django") && that.peers[key].ipv4Addresses.length == 0){
			
			delete(that.peers[key]);
			
		}
		//console.log(, );
	});
    
  }	
	
  sendDataToServer(postData = {}) {
    var headers = new HttpHeaders();
    headers.append('Access-Control-Allow-Origin' , '*');
    headers.append('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, PUT');
    headers.append("Accept", 'application/json');
    headers.append('Content-Type', 'application/json' );
    //const requestOptions = new HttpHeaders({ headers: headers });
	let that = this ;
	Object.keys(this.peers).forEach(function(key) {
		if(key.includes("Django") && that.peers[key].ipv4Addresses != []){
		  that.http.post("http://"+that.peers[key].ipv4Addresses[0]+":7995/Ingest/", postData, { headers: headers })
		  .subscribe(data => {
			  console.log(postData);
			//console.log(data['_body']);
		   }, error => {
			  console.log(error);
			//delete(that.peers[key]);
		  });
		}else if(key.includes("Django") && that.peers[key].ipv4Addresses.length == 0){
			
			delete(that.peers[key]);
			
		}
		//console.log(, );
	});
    
  }

}
